/*****************************************
  Emitting Generated Code                  
*******************************************/
class singleConditional extends ((Int)=>(Tuple2IntInt)) {
def apply(x0:Int): Tuple2IntInt = {
var x2: Int = 0
var x3: Int = 0
val x1 = x0 <= 3
val x10 = if (x1) {
x2 = x0
x3 = 2
()
} else {
x2 = 0
x3 = 0
()
}
val x11 = x2
val x12 = x3
val x13 = new Tuple2IntInt(x11,x12)
x13
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
compilation: ok
Tuple2IntInt(0,0)
/*****************************************
  Emitting Generated Code                  
*******************************************/
class nestedConditional extends ((Int)=>(Tuple2IntInt)) {
def apply(x0:Int): Tuple2IntInt = {
var x2: Int = 0
var x3: Int = 0
val x1 = x0 <= 3
val x37 = if (x1) {
var x5: Int = 0
var x6: Int = 0
val x4 = x0 >= 1
val x15 = if (x4) {
x5 = x0
val x7 = x0 + 1
x6 = x7
()
} else {
val x11 = x0 + 2
x5 = x11
x6 = x0
()
}
val x16 = x5
val x17 = x6
x2 = x16
x3 = x17
()
} else {
var x22: Int = 0
var x23: Int = 0
val x21 = x0 >= 5
val x31 = if (x21) {
x22 = x0
val x11 = x0 + 2
x23 = x11
()
} else {
val x27 = x0 + 3
x22 = x27
x23 = x0
()
}
val x32 = x22
val x33 = x23
x2 = x32
x3 = x33
()
}
val x38 = x2
val x39 = x3
val x40 = new Tuple2IntInt(x38,x39)
x40
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
compilation: ok
Tuple2IntInt(5,7)
/*****************************************
  Emitting Generated Code                  
*******************************************/
class mapper extends ((Int)=>(Tuple2IntInt)) {
def apply(x0:Int): Tuple2IntInt = {
val x2 = x0 * 2
val x1 = x0 + 1
val x3 = x1 + 3
val x4 = new Tuple2IntInt(x2,x3)
x4
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
compilation: ok
Tuple2IntInt(10,9)
